When IÂ started toÂ build myÂ first website onÂ Eleventy around 2019, IÂ had toÂ decide how toÂ deal with the HTML, CSS, and JavaScript post-processing. ByÂ that time, IÂ had gotten used toÂ the convenience ofÂ the modular approach and automation. SoÂ itÂ wasnâ€™t anÂ option toÂ just copy files from _src_ toÂ _dist_. IÂ needed them stitched, modified, and minified.

ByÂ then, IÂ got over the preprocessors like Sass, soÂ IÂ needed some light post-processing for vanilla-flavored CSS andÂ JS. IÂ looked through the [Eleventy starter projects](https://www.11ty.dev/docs/starter/) but couldnâ€™t find anything that would make sense. ItÂ was clear that early adopters ofÂ Eleventy were struggling with processing resourcesÂ too.

IÂ came upÂ with aÂ solution that worked for meÂ for aÂ few years, but IÂ recently took the next step, finally making CSS and JSÂ first-class citizens inÂ Eleventy forÂ meÂ ğŸ˜

## Vanilla all the way

The first solution IÂ came upÂ with was pretty straightforward. Before setting upÂ any post-processing, IÂ built aÂ system that didnâ€™t require any: IÂ just linked _index.css_ and _index.js_ files toÂ myÂ HTML pages that, inÂ turn, were importing other blocks/modules:

```css
/* index.css */
@import 'blocks/page.css';
@import 'blocks/header.css';
@import 'blocks/content.css';
```

InÂ the JSÂ case, you also need toÂ add `type="module"` toÂ your `<script>` toÂ make itÂ work. Oh, and for some reason, browsers need aÂ `./` prefix for relative ESM imports, but otherwise, itÂ looks pretty much the same:

```js
/* index.js */
import './modules/menu.js';
import './modules/video.js';
import './modules/podcast.js';
```

And you know what? ItÂ just worked right inÂ the browser. Yes, itÂ wasnâ€™t ideal from the performance and compatibility perspectives, but that was good enough for local development. And itÂ was super quickÂ too. When modern bundlers argue which oneâ€™s faster, IÂ often think that the fastest isÂ the one thatâ€™s not running atÂ allÂ ğŸ˜‰

SoÂ when IÂ was starting aÂ project for local development via `npm start`, itÂ was Eleventy running its server, watching for changes, and copying CSS and JSÂ files when needed. ItÂ would never work for Sass orÂ TypeScript, but IÂ always try toÂ pick the simplest tools for simple tasks.

AsÂ for the HTML, Eleventy has been taking care ofÂ itÂ for me, generating markup from Markdown, Nunjucks, and data files. OnÂ top ofÂ that, using built-in `addTransform`, IÂ added aÂ minification processing with [html-minifier-terser](https://github.com/terser/html-minifier-terser).

```js
const htmlmin = require('html-minifier-terser');

config.addTransform('html-minify', (content, path) => {
    if (path && path.endsWith('.html')) {
        return htmlmin.minify(
            content, {
                collapseBooleanAttributes: true,
                collapseWhitespace: true,
                decodeEntities: true,
                includeAutoGeneratedTags: false,
                removeComments: true,
            }
        );
    }

    return content;
});
```

âš ï¸Â This isÂ aÂ part ofÂ the bigger Eleventy config, [see the docs](https://www.11ty.dev/docs/config/).

And though IÂ liked this approach aÂ lot for local development, IÂ needed some post-processing for CSS and JSÂ toÂ make the code production-ready.

## Second pass

Running `npm run build` would give meÂ aÂ fully-functional website inÂ the _dist_ folder. IÂ only needed toÂ post-process some files before the deployment. AsÂ IÂ always liked the [Gulp](https://gulpjs.com/) for its simplicity, itÂ was anÂ obvious choice. IÂ took [PostCSS](https://postcss.org/) with some plugins for CSS and [Rollup](https://rollupjs.org/) with [Babel](https://babeljs.io/) and [Terser](https://terser.org/) plugins forÂ JS.

Hereâ€™s anÂ example ofÂ aÂ Gulp task forÂ CSS. Donâ€™t focus onÂ the list ofÂ plugins justÂ yet. Weâ€™ll have aÂ closer look atÂ them aÂ bit later.

```js
const styles = () => {
    return gulp.src('dist/styles/index.css')
        .pipe(postcss([
            require('postcss-import'),
            require('postcss-media-minmax'),
            require('autoprefixer'),
            require('postcss-csso'),
        ]))
        .pipe(gulp.dest('dist'));
};
```

IÂ enjoyed the whole system for aÂ while because IÂ didnâ€™t have toÂ build and support the Eleventy/Gulp coupling. But atÂ the same time, the additional build step botheredÂ me. Iâ€™ve been trying different approaches, from complicated npm scripts toÂ the various [Vite](https://vitejs.dev/) plugins for Eleventy, but they all didnâ€™t make meÂ happy.

## Custom Handlers

But then IÂ noticed something interesting inÂ the [Eleventy v1.0.0 changelog](https://github.com/11ty/eleventy/releases/tag/v1.0.0)Â ğŸ˜²

> Custom File Extension Handlers: applications and plugins can now add their own template types and tie them toÂ aÂ file extension.

ItÂ didnâ€™t exactly say, â€œnow you can post-process your CSS and JS,â€ but later, IÂ discovered anÂ [example inÂ the documentation](https://www.11ty.dev/docs/languages/custom/#example-add-sass-support-to-eleventy) adding Sass support toÂ Eleventy. That was precisely what IÂ needed! Not the Sass, but built-in support for processing resources.

Unlike the previous approach, Eleventy takes care ofÂ all CSS and JSÂ resources this time. Not only for aÂ production build but also during development. The closer your development build toÂ the production one, the sooner you can spot any problems. But itÂ only works ifÂ build time and live reload are fast enough not toÂ get inÂ the way during development.

Every library got its quirks: different APIs, sync/async behavior, etc. SoÂ itÂ took meÂ some time toÂ figure out how toÂ make custom handlers work with the libraries IÂ used toÂ process CSS andÂ JS. Like inÂ the Gulp case, IÂ chose [PostCSS](https://postcss.org/) forÂ CSS. For JS, IÂ decided toÂ try [esbuild](https://esbuild.github.io/), known for extremely fast build time, since IÂ needed itÂ toÂ work for both production and development.

Letâ€™s dive into each custom handler toÂ see how they work. IÂ copied them from [this websiteâ€™s Eleventy config](https://github.com/pepelsbey/pepelsbey.dev/blob/main/eleventy.config.js) and simplified itÂ aÂ little.

### CSS

Remember the file structure? WeÂ have _src/styles/index.css_ file thatâ€™s importing other CSS files relative toÂ its location. WeÂ need toÂ combine them, process aÂ bit, and output aÂ single _dist/styles/index.css_ file.

InÂ the first step, IÂ import all the packages IÂ need toÂ process myÂ styles:

- [postcss](https://www.npmjs.com/package/postcss) toÂ process files using plugins
- [postcss-import](https://www.npmjs.com/package/postcss-import) toÂ stitch all imported files together
- [postcss-media-minmax](https://www.npmjs.com/package/postcss-media-minmax) toÂ polyfill modern Media Query syntax
- [autoprefixer](https://www.npmjs.com/package/autoprefixer) toÂ prefix properties based onÂ the [browserslist](https://browserslist.dev/) config
- [postcss-csso](https://www.npmjs.com/package/postcss-csso) toÂ minimize the result

The PostCSS [plugin ecosystem](https://postcss.org/docs/postcss-plugins) isÂ quite extensive: you can build yourself the whole Sass orÂ Stylus orÂ use CSS from the future specs via [postcss-preset-env](https://github.com/csstools/postcss-plugins/tree/main/plugin-packs/postcss-preset-env) pack ofÂ plugins, but IÂ prefer toÂ write CSS thatâ€™s already supported inÂ browsers and post-process itÂ for better compatibility.

ByÂ default, CSS files are not processed byÂ Eleventy. ToÂ process them, weÂ need toÂ add CSS toÂ the template formats list using the `addTemplateFormats` method:

```js
config.addTemplateFormats('css');
```

Now Eleventy isÂ ready toÂ process our CSS files and output the result. Letâ€™s configure this processing. Otherwise, itÂ wonâ€™t beÂ different from the passthrough copy. Using `addExtension` weÂ specify what files weâ€™re going toÂ process, including output file extension and async function that will beÂ called with each fileâ€™s content and path.

```js
config.addExtension('css', {
    outputFileExtension: 'css',
    compile: async (content, path) => {
        // Processing
    }
});
```

But weÂ donâ€™t need toÂ process every CSS file that Eleventy could find inÂ the _src_ folder. WeÂ need only the _index.css_ one, the rest CSS files will beÂ imported into thisÂ one. Thatâ€™s exactly what weâ€˜re going toÂ doÂ next: filter out every other file thatâ€™s not the _index.css._

```js
if (path !== './src/styles/index.css') {
    return;
}
```

Now weÂ can finally start processing our _index.css._ And with the `path` passed into the outer function, weÂ can ask PostCSS toÂ figure out the relative location ofÂ the rest ofÂ the files. ItÂ wonâ€™t just work otherwise. IÂ learned itÂ the hard way ğŸ¥²

```js
return async () => {
    let output = await postcss([
        postcssImport,
        postcssMediaMinmax,
        autoprefixer,
        postcssCsso,
    ]).process(content, {
        from: path,
    });

    return output.css;
}
```

Our files will beÂ stitched together, polyfilled, prefixed, and minified, just like weÂ specified inÂ the list ofÂ PostCSS plugins. The output will beÂ passed toÂ Eleventy, which will write itÂ toÂ the _dist/styles/index.css._

<details>
    <summary>The final result</summary>

```js
const postcss = require('postcss');
const postcssImport = require('postcss-import');
const postcssMediaMinmax = require('postcss-media-minmax');
const autoprefixer = require('autoprefixer');
const postcssCsso = require('postcss-csso');

config.addTemplateFormats('css');

config.addExtension('css', {
    outputFileExtension: 'css',
    compile: async (content, path) => {
        if (path !== './src/styles/index.css') {
            return;
        }

        return async () => {
            let output = await postcss([
                postcssImport,
                postcssMediaMinmax,
                autoprefixer,
                postcssCsso,
            ]).process(content, {
                from: path,
            });

            return output.css;
        }
    }
});
```

</details>

### JavaScript

The same goes for JSÂ files: weÂ add template format, then process only _src/scripts/index.js_ using _esbuild_ with some simple options. This function will return the contents ofÂ all modules asÂ aÂ single file for Eleventy toÂ output into the _dist_ folder. Unfortunately, _browserslist_ isÂ not supported byÂ _esbuild,_ but itÂ seems like the `es2020` target isÂ similar toÂ what IÂ have there.

```js
return async () => {
    let output = await esbuild.build({
        target: 'es2020',
        entryPoints: [path],
        minify: true,
        bundle: true,
        write: false,
    });

    return output.outputFiles[0].text;
}
```

<details>
    <summary>The final result</summary>

```js
const esbuild = require('esbuild');

config.addTemplateFormats('js');

config.addExtension('js', {
    outputFileExtension: 'js',
    compile: async (content, path) => {
        if (path !== './src/scripts/index.js') {
            return;
        }

        return async () => {
            let output = await esbuild.build({
                target: 'es2020',
                entryPoints: [path],
                minify: true,
                bundle: true,
                write: false,
            });

            return output.outputFiles[0].text;
        }
    }
});
```

</details>

* * *

Not sure ifÂ IÂ convinced you, but Iâ€™m planning toÂ use this approach for all myÂ future projects based onÂ Eleventy. IÂ might even update the existing ones toÂ make them more maintainable. Though Iâ€™m pretty sure there are many other use cases orÂ ways toÂ doÂ it. Iâ€™m curious toÂ see what you might come upÂ with!Â ğŸ™ƒ
